---
title: Rust与C数据类型对比
date: 2025.02.08
comments: true
---

| C语言数据类型          | Rust数据类型              | 描述              | 内存占用  | 平台相关性         |
|------------------|-----------------------|-----------------|-------|---------------|
| `char`           | `char`                | 单个字符            | 1字节   | 固定            |
| `int`            | `i32`                 | 32位有符号整数        | 4字节   | 通常固定，但可能因平台而异 |
| `unsigned int`   | `u32`                 | 32位无符号整数        | 4字节   | 通常固定，但可能因平台而异 |
| `short`          | `i16`                 | 16位有符号整数        | 2字节   | 固定            |
| `unsigned short` | `u16`                 | 16位无符号整数        | 2字节   | 固定            |
| `long`           | `i64`                 | 64位有符号整数        | 8字节   | 通常固定，但可能因平台而异 |
| `unsigned long`  | `u64`                 | 64位无符号整数        | 8字节   | 通常固定，但可能因平台而异 |
| `float`          | `f32`                 | 32位浮点数          | 4字节   | 固定            |
| `double`         | `f64`                 | 64位浮点数          | 8字节   | 固定            |
| `void*`          | `*const T` 或 `*mut T` | 指针类型，具体类型依赖于上下文 | 依赖于平台 | 平台相关          |
| `size_t`         | `usize`               | 无符号整数，用于表示大小    | 依赖于平台 | 与指针大小相同       |

!!! warning "Rust中的数据类型是固定大小的，而C语言中的数据类型大小可能会根据平台和编译器的不同而有所变化"

!!! note "C中size_t、Rust中usize都与指针大小相同"

	在32位系统上，size_t通常是4字节（32位），与指针大小相同
	
	在64位系统上，size_t通常是8字节（64位），与指针大小相同
	
	使用size_t/usize是处理内存和数组索引的最佳实践

### Q：是否可以这样理解，比如新建一个double *a，这里a的数据类型是double，而指向a的指针数据是size_t类型

> 不完全正确。让我们澄清一下：
>
>1. 指针类型：在C语言中，`double *a` 声明了一个指向 `double` 类型的指针 `a`。这意味着 `a` 存储的是一个内存地址，该地址指向一个
    `double` 类型的变量或数组。
>
>2. 指针的大小：指针本身的类型是 `double *`，而不是 `size_t`。指针的大小（例如，`double *` 的大小）通常与 `size_t`
    的大小相同，但它们是不同的类型。指针类型用于指向特定类型的数据，而 `size_t` 是用于表示大小和计数的无符号整数类型。
>
>3. 内存地址：虽然指针的值（即内存地址）可以用 `size_t` 来表示，但指针本身的类型是与其指向的数据类型相关的。在C中，指针的类型是强类型的，意味着
    `double *` 和 `size_t` 是不同的类型，不能直接互换。
>
>__总结__
>
>- `double *a` 是一个指向 `double` 类型的指针。
>- 指针的值（内存地址）可以用 `size_t` 来表示，但指针本身的类型是 `double *`，而不是 `size_t`。